<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Software Engineering Overview</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f4f7fa;
            color: #333;
        }
        .container {
            max-width: 600px;
            margin: 20px auto;
            padding: 20px;
            background-color: pink;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        h1 {
            font-size: 2rem;
            color: #007bff;
            text-align: center;
            margin-bottom: 30px;
        }
        .card-header {
            background-color: #007bff;
            color: white;
            font-size: 1.3rem;
            border-radius: 8px 8px 0 0;
            padding: 10px 15px; max-width: 400px;
        }
        .card-body {
            padding: 20px;
        }
        .highlight {
            color: #007bff;
            font-weight: bold;
        }
        ul {
            list-style-type: square;
            margin-left: 20px;
        }
        ul li {
            margin-bottom: 8px;
        }
        footer {
            text-align: center;
            margin-top: 50px;
            font-size: 1rem;
            color: #777;
        }
        header { font-size: 2rem;
            color: #007bff;
            text-align: center;
            margin-bottom: 30px;
        }
            
        }
    </style>
</head>
<body>      
    <div class="container">
  <header> 2081 quation paper </header>
      
        
        <!-- Deliverables and Milestones -->
       
            <h2 style="max-width: 900px; font-size: 1.5rem; background-color:yellow ;"> (1)<td>Explain deliverables and milestones with an explain . describe  the term measures , metrics and measurement [4+6]</h2>
    
                <h5 class="highlight">Deliverables</h5>
                <p>Deliverables are tangible or intangible outcomes produced during a project. They are the actual products, reports, or services created at different phases of the project.</p>
                <ul>
                    <li>Design documents</li>
                    <li>Website prototypes</li>
                    <li>Final website or software product</li>
                    <li>Testing results</li>
                </ul>
                <h5 class="highlight">Milestones</h5>
                <p>Milestones are significant points or events in a project's timeline that mark progress toward completion.</p>
                <ul>
                    <li>Completion of the project plan</li>
                    <li>Approval of design mockups</li>
                    <li>Completion of the testing phase</li>
                    <li>Project launch</li>
                </ul>
            
        

        
            
                <h5 class="highlight">Measures</h5>
                <p>Measures are the raw, quantitative attributes of an object, process, or event. They are the direct observations or counts.</p>
                <p><strong>Example:</strong> The number of lines of code written, the count of test cases passed.</p>
                <h5 class="highlight">Metrics</h5>
                <p>Metrics are calculated or derived values that help in decision-making. They are created using measures and provide meaningful insights.</p>
                <ul>
                    <li>Code coverage (percentage of code tested)</li>
                    <li>Defect density (number of defects per 1,000 lines of code)</li>
                    <li>Conversion rate (number of users who complete a specific action divided by total users)</li>
                </ul>
                <h5 class="highlight">Measurement</h5>
                <p>Measurement is the process of collecting and quantifying data about specific attributes. It’s the act of assigning numbers to objects, events, or processes according to defined rules.</p>
                <p><strong>Example:</strong> Measuring website loading time using a stopwatch or automated tool.</p>











        <h1 style="margin: 0;
            font-size: 1.5rem; background-color: yellow; max-width: 600px;">(2)<td><td> Explain any four  role performed by system  analyst .what are the role of management in software development [4+6]</h1>

        <!-- Roles of System Analyst -->
       
                <h5 class="highlight">1. Requirements Gathering[4]</h5>
                <p>A system analyst works closely with stakeholders, such as clients, users, and other departments, to gather and document system requirements. This involves understanding business needs and ensuring that they are translated into technical specifications.</p>
                <h5 class="highlight">2. System Design</h5>
                <p>Based on the requirements, the system analyst designs the architecture of the system. This involves specifying how the system should be structured, including its components, interactions, and data flow.</p>
                <h5 class="highlight">3. Feasibility Study</h5>
                <p>The system analyst assesses the feasibility of the project by evaluating technical, operational, and financial factors. This ensures that the proposed system can be developed within the constraints of the organization.</p>
                <h5 class="highlight">4. Testing and Evaluation</h5>
                <p>After the system is developed, the system analyst plays a role in testing the system to ensure it meets the specified requirements. They assist in identifying issues and ensuring the system's functionality is aligned with user needs.</p>
         

        <!-- Roles of Management -->
       
               
                <h5 class="highlight"> Roles of Management in Software Development[6]</h5>
       
                <h5 class="highlight">1. Resource Allocation</h5>
                <p>Management is responsible for allocating the necessary resources (such as human resources, technology, and budget) to ensure that the software development project can proceed effectively. This includes hiring developers, purchasing software, and ensuring adequate infrastructure.</p>
                <h5 class="highlight">2. Project Planning and Scheduling</h5>
                <p>Management oversees the planning and scheduling of the software development process. This includes setting milestones, timelines, and deadlines to ensure the project progresses smoothly and is completed on time.</p>
                <h5 class="highlight">3. Risk Management</h5>
                <p>Management identifies potential risks that might impact the software development project, such as technical challenges, financial issues, or market changes. They develop strategies to mitigate these risks and ensure the project stays on track.</p>
                <h5 class="highlight">4. Quality Assurance</h5>
                <p>Management ensures that the software meets quality standards by supporting testing, reviewing code, and implementing best practices. They help in making sure that the software is reliable, user-friendly, and meets the needs of the users.</p>
                <h5 class="highlight">5. Decision Making</h5>
                <p>Management plays a crucial role in making decisions that impact the course of software development. They prioritize features, handle changes in requirements, and make critical decisions about the direction of the project.</p>
                <h5 class="highlight">6. Stakeholder Communication</h5>
                <p>Management serves as the bridge between the development team and other stakeholders, such as clients, investors, or executives. They ensure that 




        <h1  style="margin: 0;
            font-size: 1.5rem; background-color: yellow; max-width: 600px;">(3)<td><td> What do you mean by DFD? explain different levels with suitable example[2+8]</h1>

    
          <h3> What do you mean by DFD[2]</h3>
                <p>A <strong>Data Flow Diagram (DFD)</strong> is a graphical representation of the flow of data within a system. It illustrates how data moves between processes, data stores, and external entities. DFDs are used to visualize the structure and behavior of a system and help in understanding the data transformations that occur as input flows through different processes to produce output. It helps in both system analysis and design by depicting the system’s functionality and interactions.</p>
         
        <!-- DFD Levels Explanation -->   <h3>  explain different levels with suitable exampl[8]</h3>
       
                <h5 class="highlight">1. Level 0 DFD (Context Diagram)</h5>
                <p>This is the highest level of abstraction, representing the entire system as a single process. It shows the system boundary, the external entities interacting with the system, and the data flow between them.</p>
                <p><strong>Example</strong>: Imagine an <em>Online Bookstore</em> system. In the Level 0 DFD, the system itself is represented as a single process, and the external entities could be:</p>
                <ul>
                    <li>Customers (who provide orders and receive products)</li>
                    <li>Bank (for payment transactions)</li>
                    <li>Supplier (providing book inventory)</li>
                </ul>
                <p>Data flows would show customers placing orders, payments being processed by the bank, and books being delivered by the supplier.</p>

                <h5 class="highlight">2. Level 1 DFD (Decomposition of the System)</h5>
                <p>This level provides more detail by breaking down the system into major functional components or processes. It shows the processes in the system, how data flows between them, and where data is stored.</p>
                <p><strong>Example</strong>: In the Online Bookstore system, at Level 1, the main process (order processing) is broken down into smaller sub-processes:</p>
                <ul>
                    <li>Order placement</li>
                    <li>Payment processing</li>
                    <li>Inventory management</li>
                    <li>Order delivery</li>
                </ul>

                <h5 class="highlight">3. Level 2 DFD (Further Decomposition)</h5>
                <p>This level further decomposes the processes of the Level 1 DFD into smaller sub-processes, providing even more detail on how each process works.</p>
                <p><strong>Example</strong>: For the <em>Order Processing</em> process in the Online Bookstore, you might decompose it into:</p>
                <ul>
                    <li>Check product availability</li>
                    <li>Add items to cart</li>
                    <li>Generate order summary</li>
                </ul>

                <h5 class="highlight">4. Level 3 DFD (Detailed Decomposition)</h5>
                <p>The Level 3 DFD is the most detailed version, showing every action within a particular process, usually describing every step in the process.</p>
                <p><strong>Example</strong>: For Process 1.1 "Check product availability," it could be further decomposed into:</p>
                <ul>
                    <li>Query inventory database</li>
                    <li>Validate product quantity</li>
                    <li>Notify customer of availability</li>
                </ul>



        
        <h1  style="margin: 0;
            font-size: 1.5rem; background-color: yellow; max-width: 600px;">(4)<td><td>  what is feasibility analysis ? cost-benefits analysis technique with example [2+8]</h1>

        <!-- Feasibility Analysis Explanation --> 
                <p><strong>Feasibility analysis</strong> is the process of evaluating the practicality of a proposed project or system. It determines whether a project is viable and worth pursuing, considering factors such as technical, operational, and financial aspects. The goal is to ensure that the project can be developed within the given constraints, such as time, resources, and budget, and whether it will meet the intended goals. Feasibility analysis typically covers four main types of feasibility: technical, operational, economic, and legal.</p>
          
                <p><strong>Cost-Benefit Analysis (CBA)</strong> is a technique used to assess the overall value of a project by comparing its costs to the benefits it is expected to generate. The objective is to determine if the benefits outweigh the costs, thereby justifying the investment in the project. CBA helps decision-makers choose the most cost-effective solution and prioritize projects based on their net benefits.</p>

                <h5 class="highlight">Steps in Cost-Benefit Analysis:[8]</h5>
                <ul>
                    <li><strong>Identify the Costs and Benefits</strong>: This includes both monetary and non-monetary costs and benefits.</li>
                    <li><strong>Quantify the Costs and Benefits</strong>: Assigning monetary values to both costs and benefits for comparison.</li>
                    <li><strong>Calculate Net Benefit</strong>: Subtract the total costs from the total benefits to get the net benefit.</li>
                    <li><strong>Perform Sensitivity Analysis</strong>: Evaluate how sensitive the results are to changes in assumptions.</li>
                    <li><strong>Make the Decision</strong>: If the benefits exceed the costs, the project is deemed feasible.</li>
                </ul>

                <h5 class="highlight">Example of Cost-Benefit Analysis:</h5>
                <p>Let's consider a company planning to implement a new software system.</p>
                <ul>
                    <li><strong>Costs:</strong>
                        <ul>
                            <li>Software purchase: $50,000</li>
                            <li>Training employees: $10,000</li>
                            <li>Implementation and integration: $20,000</li>
                            <li>Annual maintenance: $5,000</li>
                        </ul>
                        <strong>Total Costs:</strong> $90,000 (over 5 years)
                    </li>
                    <li><strong>Benefits:</strong>
                        <ul>
                            <li>Improved employee productivity: $60,000 per year</li>
                            <li>Reduced errors and rework: $20,000 per year</li>
                            <li>Enhanced customer satisfaction leading to more sales: $30,000 per year</li>
                        </ul>
                        <strong>Total Benefits:</strong> $110,000 per year
                    </li>
                    <li><strong>Net Benefit:</strong> Over 5 years: $550,000 (benefits) - $90,000 (costs) = $460,000</li>
                </ul>

        <h1 style="margin: 0;
            font-size: 1.5rem; background-color: yellow; max-width: 600px;">(5)<td><td>  what is feasibility analysis ?
            what is feasibility analysis ? cost-benefits analysis technique with example [2+8]</h1>

      
            
                <p><strong>Project planning</strong> is the process of defining the scope, objectives, tasks, and resources required to complete a project successfully. It involves creating a detailed roadmap that outlines the steps, timeline, and resources needed to achieve the project's goals. Project planning is crucial to ensuring that the project is completed on time, within budget, and meets the specified quality standards. It includes activities like task breakdown, resource allocation, risk management, and scheduling.</p>
         

      
                <p><strong>COCOMO (Constructive Cost Model)</strong> is a widely used software cost estimation model developed by Barry Boehm in 1981. It is used to estimate the cost, effort, and time required to develop a software project based on the size and complexity of the project. COCOMO is based on historical data from software development projects and provides a mathematical model for predicting project parameters.</p>

                <h5 class="highlight">Levels of COCOMO Model:</h5>

                <h6 class="highlight">1. Basic COCOMO:</h6>
                <p>This is the simplest form of the model and provides a rough estimate based on the size of the project (measured in lines of code). The formula is:</p>
                <pre><code>E = a × (KLOC)^b</code></pre>
                <p>Where: <br>
                    E = Effort required (person-months) <br>
                    KLOC = Number of thousands of lines of code (Kilo Lines of Code) <br>
                    a and b are constants determined empirically, and vary depending on the type of software (e.g., organic, semi-detached, or embedded).</p>

                <h6 class="highlight">2. Intermediate COCOMO:</h6>
                <p>This version includes additional factors to account for project attributes such as hardware, personnel, and experience. These factors are multiplied by the basic COCOMO estimate. The formula is:</p>
                <pre><code>E = a × (KLOC)^b × Cost Drivers</code></pre>

                <h6 class="highlight">3. Detailed COCOMO:</h6>
                <p>This is the most detailed version, which includes all factors from the intermediate model, with the breakdown of the project into individual modules. It evaluates the impact of various factors on each module's development.</p>

        <h1 style="margin: 0;
            font-size: 1.5rem; background-color: yellow; max-width: 600px;">Define software  quality. explain about capability maturity model (CMM) [2+8]</h1>

      
                <p><strong>Software quality</strong> refers to the degree to which a software product meets the specified requirements, satisfies user needs, and adheres to predefined standards. It involves various attributes such as functionality, reliability, efficiency, maintainability, and usability. High-quality software ensures that it is bug-free, performs well under expected conditions, and is user-friendly. Software quality can be measured through testing, reviews, and metrics such as defect density, response time, and customer satisfaction.</p>
      

        <!-- Capability Maturity Model (CMM) Explanation -->
      
                <p><strong>The Capability Maturity Model (CMM)</strong> is a framework that provides organizations with a structured approach to improving their software development processes. It helps assess their current process maturity and guides them through necessary improvements to increase process effectiveness and efficiency.</p>

                <h5 class="highlight">Levels of CMM:</h5>
                <h6 class="highlight">1. Level 1: Initial</h6>
                <p>At this level, processes are ad-hoc and chaotic. Success depends on individual efforts, with no established processes for software development. The focus is on reacting to immediate challenges.</p>

                <h6 class="highlight">2. Level 2: Managed</h6>
                <p>Basic project management processes are in place, and work products are managed and controlled. This level focuses on meeting cost, schedule, and quality goals.</p>

                <h6 class="highlight">3. Level 3: Defined</h6>
                <p>Processes are standardized and documented across projects. The focus is on establishing a process that can be consistently applied, emphasizing quality and continual improvement.</p>

                <h6 class="highlight">4. Level 4: Quantitatively Managed</h6>
                <p>Quantitative data and metrics are used to manage and control processes. The focus is on improving performance through data-driven decisions and continuous monitoring.</p>

                <h6 class="highlight">5. Level 5: Optimizing</h6>
                <p>The highest maturity level, focusing on continuous improvement through innovative technologies and techniques. Processes are stable, and improvements 


        <h1 style="margin: 0;
            font-size: 1.5rem; background-color: yellow; max-width: 600px;"> What are  the objectives for  output  design ? software risk  management [[4+6]</h1>

        
                <p>The <strong>objectives for output design</strong> focus on ensuring that the information generated by a system is useful, accurate, and presented in a manner that meets the needs of the users. Effective output design helps enhance user satisfaction and decision-making capabilities. The key objectives for output design are:</p>
                <ul>
                    <li><strong>Clarity and Readability:</strong> The output must be easy to read and interpret by the users, using appropriate fonts, layouts, and formatting.</li>
                    <li><strong>Accuracy and Reliability:</strong> The output must be accurate, free from errors, and consistently produced, reflecting the correct data.</li>
                    <li><strong>Timeliness:</strong> The output should be delivered at the right time, ensuring it is available when needed.</li>
                    <li><strong>User-Centric Presentation:</strong> Outputs should be tailored to the users' needs, presenting information in a format that the user can easily comprehend.</li>
                </ul>
          
                <p><strong>Software risk management</strong> is the process of identifying, assessing, and mitigating potential risks throughout the software development lifecycle. The goal is to minimize the impact of risks and ensure the successful completion of the project. The key aspects of software risk management are:</p>
                <ul>
                    <li><strong>Risk Identification:</strong> Identifying potential risks that could affect the project’s success, including technical, operational, and external risks.</li>
                    <li><strong>Risk Assessment:</strong> Assessing the likelihood and potential impact of identified risks, classifying them based on severity and probability.</li>
                    <li><strong>Risk Mitigation:</strong> Developing strategies to minimize or eliminate risks, such as adopting alternative technologies or creating contingency plans.</li>
                    <li><strong>Risk Monitoring:</strong> Continuously monitoring risks throughout the project lifecycle to track and adjust mitigation strategies.</li>
                    <li><strong>Risk Control:</strong> Taking actions to reduce the likelihood or impact of risks, such as reallocating resources or revising plans.</li>
                    <li><strong>Risk Communication:</strong> Ensuring clear communication of risks and mitigation plans to stakeholders to maintain transparency and enable informed decision-making.</li>
          



        <h1 style="margin: 0;
            font-size: 1.5rem; background-color: yellow; max-width: 600px;">(8)<td><td>what is software verification ? Describe the different software testing  process[2+8]</h1>

                <p><strong>Software verification</strong> is the process of evaluating a system or its components to ensure that they meet the specified requirements and function correctly. It answers the question, <span class="text-primary"><strong>"Are we building the product right?"</strong></span> Verification involves reviews, walkthroughs, and inspections, ensuring the product is built according to design specifications.</p>
          
                <p>The <strong>software testing process</strong> ensures that the product meets quality standards and performs as expected. The key steps are:</p>
                <ul>
                    <li><strong>Requirement Analysis:</strong> Understand and analyze the requirements to identify testable elements and define testing objectives.</li>
                    <li><strong>Test Planning:</strong> Create a test plan outlining strategies, schedules, resources, and tools, assigning roles to the testing team.</li>
                    <li><strong>Test Design:</strong> Develop test cases and scripts based on requirements and prepare test data for validation.</li>
                    <li><strong>Test Environment Setup:</strong> Establish hardware, software, and network configurations to simulate the production setup.</li>
                    <li><strong>Test Execution:</strong> Execute test cases, log defects, and document test results.</li>
                    <li><strong>Defect Reporting and Tracking:</strong> Record issues found during testing and track them for resolution.</li>
                    <li><strong>Regression Testing:</strong> Re-test after fixing defects to ensure changes don’t impact other parts of the software.</li>
                    <li><strong>Test Closure:</strong> Evaluate test completion criteria, document findings, and deliver the final test report.</li>
                </ul>
            
      

        <h1 style="margin: 0;
            font-size: 1.5rem; background-color: yellow; max-width: 600px;">(9)<td><td> different  between   re-engineering and reverse engineering .why  do we need  software maintenance[5+5] </h1>

   
                <table class="table table-bordered " >
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Re-engineering</th>
                            <th>Reverse Engineering</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Definition</strong></td>
                            <td>Re-engineering involves modifying and improving existing software to enhance its functionality, performance, or maintainability.</td>
                            <td>Reverse engineering involves analyzing and understanding the structure, functionality, and components of existing software.</td>
                        </tr>
                        <tr>
                            <td><strong>Objective</strong></td>
                            <td>To upgrade or optimize software for future use and to adapt it to new requirements or technologies.</td>
                            <td>To understand the software’s internal workings, often without prior documentation.</td>
                        </tr>
                        <tr>
                            <td><strong>Focus</strong></td>
                            <td>Improving and extending the life of the software.</td>
                            <td>Understanding the existing design, code, or architecture.</td>
                        </tr>
                        <tr>
                            <td><strong>Outcome</strong></td>
                            <td>Results in an improved version of the software, with enhancements or optimizations.</td>
                            <td>Results in documentation or a model that describes the current state of the software.</td>
                        </tr>
                        <tr>
                            <td><strong>When Used</strong></td>
                            <td>When the software needs updates, performance improvements, or functionality changes.</td>
                            <td>When no prior documentation exists, or when understanding legacy software is required for maintenance or modernization.</td>
                        </tr>
                    </tbody>
                </table>
            
                <p><strong>Software maintenance</strong> is essential to ensure that software remains functional, reliable, and relevant after deployment. Key reasons include:</p>
                <ul>
                    <li><strong>Bug Fixing:</strong> Correcting errors or defects identified in the software after deployment to ensure smooth operation.</li>
                    <li><strong>Performance Improvement:</strong> Optimizing the software to enhance speed, efficiency, or resource utilization.</li>
                    <li><strong>Adaptation to Changes:</strong> Modifying the software to work with new hardware, operating systems, or third-party integrations.</li>
                    <li><strong>Adding Features:</strong> Enhancing the software with new functionalities or improvements to meet evolving user needs.</li>
                    <li><strong>Security Updates:</strong> Addressing vulnerabilities to protect against potential security threats and ensure data safety.</li>
                </ul>
         <h  style="margin: 0;
            font-size: 1.5rem; background-color: yellow; max-width: 600px;"> 10<td><td> write the short note (any tow)[2*5]</h>

        <h1  style="margin: 0;
            font-size: 1.5rem; background-color: yellow; max-width: 300px;">(a)<td><td>E-R Diagram Explanation</h1>

       
                <p>An <strong>Entity-Relationship (E-R) Diagram</strong> is a graphical representation of the entities, attributes, and relationships within a database system. It helps in designing the database structure clearly and systematically. Below are the key components of an E-R Diagram:</p>
                <ul>
                    <li><strong>Entities:</strong> Represented as rectangles. Entities are objects or concepts in the system, such as "Student" or "Course."</li>
                    <li><strong>Attributes:</strong> Represented as ovals connected to entities. Attributes provide details about an entity, such as "Name," "ID," or "Age."</li>
                    <li><strong>Relationships:</strong> Represented as diamonds. Show associations between entities, such as "Enrolls" connecting "Student" and "Course."</li>
                    <li><strong>Primary Key:</strong> An attribute that uniquely identifies an entity instance, usually underlined in the diagram.</li>
                    <li><strong>Cardinality:</strong> Defines the number of instances of one entity related to another. Examples include One-to-One (1:1), One-to-Many (1:N), or Many-to-Many (M:N).</li>


        <h1 style="margin: 0;
            font-size: 1.5rem; background-color: yellow; max-width: 300px;">(b)<td><td>Documentation </h1>

    
                <p><strong>Documentation</strong> in software engineering refers to the process of creating and maintaining written records that describe the design, implementation, functionality, and usage of software. It plays a crucial role in ensuring clear communication among stakeholders, aiding in maintenance, and providing guidance for users.</p>
                    <strong>Type of Documentation</strong>

       
                <ul>
                    <li><strong>User Documentation:</strong> Intended for end-users, including manuals, tutorials, FAQs, and guides to help users understand the software.</li>
                    <li><strong>Technical Documentation:</strong> For developers, testers, and maintainers. Contains system design details, architecture diagrams, API references, and code comments.</li>
                    <li><strong>Process Documentation:</strong> Covers the methodologies, processes, and workflows followed during software development. Examples: Agile workflows, test plans, or version control logs.</li>
                </ul>
                      <strong>Importance of Documentation</strong>

              
                <ul>
                    <li><strong>Improves Communication:</strong> Provides a shared understanding among team members and stakeholders.</li>
                    <li><strong>Eases Maintenance:</strong> Helps future developers understand the software's functionality and design, making debugging and updates easier.</li>
                    <li><strong>Facilitates Training:</strong> New team members can quickly learn about the software through existing documentation.</li>
                    <li><strong>Ensures Compliance:</strong> Meets legal or industry-specific regulations by providing detailed records.</li>
                    <li><strong>Enhances Quality:</strong> Clear documentation reduces misunderstandings and errors in development and usage.</li>
                </ul>
          
           <strong>Best Practices for Effective Documentation</strong>
               
          
                <ul>
                    <li>Keep it clear, concise, and structured.</li>
                    <li>Use visual aids like diagrams and flowcharts.</li>
                    <li>Update documentation regularly to reflect changes.</li>
                    <li>Use tools like wikis, project management software, or documentation generators.</li>
                </ul>
           

        <h2 style="margin: 0;
            font-size: 1.5rem; background-color: yellow; max-width: 300px;">(c)<td><td>Agile Model </h2>

       
             
            
                <p><strong>The Agile model</strong> in software engineering is an approach to software development that emphasizes flexibility, collaboration, and customer-centricity. It focuses on delivering small, incremental changes in software through iterative cycles, known as sprints, rather than a single large release at the end of the project.</p>
           
                <h1>Key Principles of Agile</h1>
            
                <ul>
                    <li><strong>Customer Collaboration Over Contract Negotiation:</strong> Emphasizes ongoing interaction with the customer to ensure that the product meets their needs and expectations.</li>
                    <li><strong>Responding to Change Over Following a Plan:</strong> Allows for changes in requirements and priorities during the development process, ensuring adaptability.</li>
                    <li><strong>Individuals and Interactions Over Processes and Tools:</strong> Focuses on the people working on the project and their collaboration rather than just the tools or processes used.</li>
                    <li><strong>Working Software Over Comprehensive Documentation:</strong> Prioritizes delivering functional software over creating exhaustive documentation, though documentation still plays an important role.</li>
                </ul>
           

        
              <h4>  Agile Development Process</h4>
           
                <ul>
                    <li><strong>Planning:</strong> Teams set initial goals and prioritize features.</li>
                    <li><strong>Design and Development:</strong> Incremental development of features in short sprints.</li>
                    <li><strong>Testing:</strong> Each iteration includes testing to ensure the software works as intended.</li>
                    <li><strong>Review and Retrospective:</strong> After each sprint, there is a review to assess progress and identify improvements for the next sprint.</li>
                </ul>
           
               <h4> Agile Methodologies</h4>
            
                <p>Agile methodologies include frameworks like Scrum, Kanban, and Extreme Programming (XP), which provide more specific structures for managing development cycles and improving teamwork. The goal is to deliver a high-quality product that meets the user's needs, with continuous improvement throughout the development cycle.</p>
            

          
            </div>
        </div>
    </div>
    <footer>
        <p>&copy; 2025 Software Engineering Overview. All rights reserved.</p>
    </footer>
</body>
</html>
